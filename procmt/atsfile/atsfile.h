/***************************************************************************
**                                                                        **
**  ProcMT and modules                                                    **
**  Copyright (C) 2017-2021 metronix GmbH                                 **
**                                                                        **
**  This program is free software: you can redistribute it and/or modify  **
**  it under the terms of the GNU General Public License as published by  **
**  the Free Software Foundation, either version 3 of the License, or     **
**  (at your option) any later version.                                   **
**                                                                        **
**  This program is distributed in the hope that it will be useful,       **
**  but WITHOUT ANY WARRANTY; without even the implied warranty of        **
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         **
**  GNU General Public License for more details.                          **
**                                                                        **
**  You should have received a copy of the GNU General Public License     **
**  along with this program.  If not, see http://www.gnu.org/licenses/.   **
**                                                                        **
** Parts of the software are linked against the Open Source Version of Qt **
** Qt source code copy is available under https://www.qt.io               **
** Qt source code modifications are non-proprietary,no modifications made **
** https://www.qt.io/licensing/open-source-lgpl-obligations               **
****************************************************************************
**           Author: metronix geophysics                                  **
**  Website/Contact: www.metronix.de                                      **
**                                                                        **
**                                                                        **
****************************************************************************/

#ifndef ATSFILE_H
#define ATSFILE_H

#include "atsfile_global.h"
#include "procmt_alldefines.h"
#include "threadbuffer.h"
#include "atsheader.h"


#include <QDataStream>
#include <QFile>
#include <QFileInfo>
#include <QtEndian>
#include <QStringView>
#include <QDate>
#include <QObject>
#include <thread>
#include <algorithm>
#include <queue>

#include <atmfile.h>
#include "fftreal_vector.h"
#include "iterator_templates.h"
#include "firfilter.h"

#include <memory>
#include <complex>


//!< @todo can not use move back and forth ! check


/*!
   \brief The atsfile class contains the complete file maintainance, including read/write, create atm and so on<br>
   The class can later used as thread with a "moveToThread". The main event loop is implemented here in the from of
   read_all, write_all and so on. You can NOT use these functions outside a thread.<br>
   The class shall deliver:<br>
   ts data<br>
   ts data scaled<br>
   complex raw spectra<br>
   amplitude spectra<br>
   calibrated complex spectra<br>
   calibrated amplitude spectra<br>
   Strategy: SET all what you want for the output file; some changes will become active ONLY when writing, example<br>
   set the FIR decimation<br>
   the input file still needs the original time and sample frequency<br>
   output files will be generated by input files - setting will be known<br>
   when writing or re-writing the header changes such as sample are getting active here<br>
   so: set_smaple_freq() is the stupid solution because we always use in -> out<br>
   the SLOT controlls the thread

 */
class atsfile : public atsheader
{
    Q_OBJECT
public:
    explicit atsfile(const QFileInfo &qfi, const short int &header_version = 0, QObject *parent = Q_NULLPTR);
    explicit atsfile(const QFileInfo &qfi, const size_t &slot = 0, const short int &header_version = 0, QObject *parent = Q_NULLPTR);
    explicit atsfile(const QString &dir, const QString &name, const short int &header_version = 0, QObject *parent = Q_NULLPTR);
    explicit atsfile(const atsfile &atsf);
    explicit atsfile(const QFileInfo &qfi, const int &file_version, const int header_version, const int &system_serial_number, const double &sample_freq,
                     const int &run_number, const int &channel_number,
                     const QString &channel_type, const QString &ADB_board_type = "", const QString &observatory = "",
                     const QString &ceadate = "", const QString &ceameastype = "");

    explicit atsfile( QObject *parent = Q_NULLPTR);

    ~atsfile();

    std::unique_ptr<atmfile>   atm = nullptr;                       //!< selection, grey shaded == true -> selected for NOT to be processed

    /*!
     * \brief open_atm
     * \param open_0_onthefly_1_create_2 0 = open only exist, deletes atm if no file, 1 create a atm selection
     * \return
     */
    bool open_atm(const int open_0_onthefly_1_create_2 = 0);

    void reset_buffer();


    size_t concat(std::shared_ptr<atsfile> &rhs);

    /*!
       \brief get_create_buffer as a producer atsfile creates the buffer and returns a shared pointer to it
              when this class is destroyed the buffer is released
              also others shold release the buffer a.s.a.p when they finished
       \param nbuffers
       \param buffer_type
       \return
     */
    std::shared_ptr<threadbuffer<double>>  get_create_buffer(const size_t &nbuffers, const atsfileout &buffer_type);
    std::shared_ptr<threadbuffer<std::complex<double>>>  get_create_cplx_buffer(const size_t &nbuffers, const atsfileout &buffer_type);
    std::shared_ptr<threadbuffer<int>>  get_create_int_buffer(const size_t &nbuffers, const atsfileout &buffer_type);

    std::shared_ptr<threadbuffer<QString>>  get_create_csv_buffer(const size_t &nbuffers);


    bool csvline(const QString &line_in);
    QString phoenix_json_ts_tag() const;


    std::shared_ptr<threadbuffer<double>>  get_create_double_input_buffer(const size_t &nbuffers, const atsfileout &buffer_type, const size_t size);




    /*!
       \brief set_window_length this is the essential function for reading data and INITIALIZING the threadbuffer  <br>
              if you use MULTIPLE file you must check that ALL get the SAME UPPER frequency - in advance
              this may happen if you use 06e and 07e : 10kHz is max 06e and 50 kHz is may 07e<br>
              ATTENTION if \ref sync_for_max_min_time was called (to sync with other ats files, the functions uses override_use_samples !!! If you CHOP ats files make sure that sync_for_max_min_time was NOT called<br>
       \param wl size of window, e.g. 1024, ... 8192; if you do FFT it must be a power of mostly
       \param last_read if we want to read the last chunk - e.g. when converting to ASCII
       \return true if a solution for window length could be found
     */
    bool set_window_length(const size_t &wl, const double &fcut_upper = 0.0 , const double &fcut_lower = 0.0, const bool &last_read = false, const quint64 &use_samples = 0, const quint64 &overlapping = 0, const atsfileout &buffer_type = atsfileout::atsfileout_void);



    /*!
     * \brief min_max_cal  assumption is the same sampling frequencies of all files BUT different calibration
     * \param wl
     * \param get_maxf max cal or fft freq if no cal
     * \param get_minf min cal or fft freq if no cal
     *
     */

    /*!
     * \brief min_max_cal  assumption is the same sampling frequencies of all files BUT different calibration
     * \param wl window length of fft
     * \param get_maxf max cal or fft freq if no cal, 0 if fail
     * \param get_minf min cal or fft freq if no cal, 0 if fail
     * \param min_cut_upper if 20k is fft, 10k is the cal, mimimum  is 0.50 to cut 8or more like 0.55)
     * \param min_cut_lower
     * \return false if fail
     */
    bool min_max_cal(const size_t &wl, double &get_maxf, double &get_minf, double &max_cut_upper, double &min_cut_lower, const bool limit_upper_to_cal);

    /*!
       \brief set_buffer_type the type controls the data flow, stacking and so on
       \param buffer_type
     */
    void set_buffer_type(const atsfileout &buffer_type);

    /*!
     * \brief set_buffer this should be the buffer for receiving and writing
     * \param buffer
     */
    void set_buffer(std::shared_ptr<threadbuffer<double>> &buffer);

    void clear(const short header_version = 0);



    /*!
       \brief scan_header_close - re-implemented from atsheader, opens AND closes the file, checks the filename additionally
       \return samples of ats file or SIZE_MAX if empty
     */
    size_t scan_header_close();

    /*!
       \brief read_header - re-implemented from atsheader, opens the file, checks the filename additionally
       \return samples of ats file or SIZE_MAX if empty
     */
    size_t read_header();

    /*!
       \brief get_filepos
       \return actual file position
     */
    qint64 get_filepos() const;


    /*!
       \brief get_read_counts
       \return actual readings
     */
    size_t get_read_counts() const {return ats_read_counts;}

    /*!
       \brief get_write_counts
       \return actual write counts
     */
    size_t get_write_counts() const {return ats_write_counts;}


    /*!
       \brief get_window_length
       \return the actual used window length
     */
    size_t get_window_length() const;


    /*!
     * \brief get_spectra_length
     * \return fft size AFTER cut low/high
     */
    size_t get_spectra_length() const;

    /*!
     * \brief get_freqs return frequencies used by fft and e.g.calibration (calib maintains a copy)
     * \return
     */
    std::vector<double> get_frequencies() const;


    size_t get_max_counts() const;

    void set_output(atsfileout out);

    /*!
     * \brief get_samples_written
     * \return amount of written samples
     */
    size_t get_samples_written() const {return samples_written;}

    /*!
     * \brief get_samples_read amount of samples read - including overlapp; during processing, not sliding
     * \return
     */
    size_t get_samples_read() const { return samples_read; }

    /*!
     * \brief get_sample_pos calculates the actual sample to read next from the file pos; returns 0, 1023 ... if wl = 1024
     * \return
     */
    size_t get_sample_pos() const;

    quint64 set_write_double_vector(const std::vector<double> &complete_double_data, const double &lsb_mv);

    quint64 append_int32(const std::vector<int32_t> &v);
    quint64 append_int64(const std::vector<int64_t> &v);



    quint64 read_ascii_file(const QFileInfo &ascii_file, const bool isVolt, const bool is_64bit = false);

    void get_tsdata(std::vector<double>& data) const;
    quint64 dump_tsbuffer(const QString& filename, const eQDateTime& startsat, const quint64 &current_sample_position, const bool timecol = false) const;
    quint64 dump_spc_tsplotter(const QString& filename) const;
    quint64 dump_spc_tsplotter_stacked(const QString& filename) const;


signals:

    void slided();                  //!< indicates the a next possible read is available (if connected)

    void ats_thrd_tsdata_ready(const std::vector<double> &tsdata, const size_t &ats_read_counts, const size_t &slot, const bool &last = false);
    void ats_thrd_spcdata_ready(const std::vector<std::complex<double>> &spcdata, const size_t &ats_read_counts, const size_t &slot, const bool &last = false);
    void ats_thrd_ampl_spcdata_ready(const std::vector<double> &spcdata, const size_t &ats_read_counts, const size_t &slot, const bool &last = false);

    void signal_counts_per(const int counts);

    void signal_start_window_sample(const size_t sample_no);

    /*!
     * \brief signal_loop_status get the loop counter and read samples (which can be bigger as file size when move back is active)
     * \param loop_counts
     * \param read_samples
     */
    void signal_loop_read_status(const size_t& ats_read_counts, const size_t& samples_read );

    void signal_loop_write_status(const size_t& ats_write_counts, const size_t& samples_written );

    void signal_get_max_counts_and_last(const size_t &max_counts, const size_t &last_reading) const;

    void signal_fft_freqs(const std::vector<double> &freqs);

    void signal_input_cal_used(const QString sensortype, const int sernum, const QString channel_type, const std::vector<double> &freqs, const std::vector<double> &ampls, const std::vector<double> &degs, const int chopper);

    void signal_interpolated_cal_used(const QString sensortype, const int sernum, const QString channel_type, const std::vector<double> &freqs, const std::vector<double> &ampls, const std::vector<double> &degs, const int chopper);

    void tx_message(const int &slot, const QString &message);

    void read_all_single_finished(std::vector<double> &all_ts_scaled, const bool &write_immedeately);


    /*!
     * \brief signal_guess_100 some features can only guess where we are, so mit 10, 20, 90 and main 100
     * \param value_0_100
     */
    void signal_guess_100(int value_0_100);

    void signal_tsdata(const std::vector<double> &data, const int &slot);

    void signal_spcdata(const std::vector<double> &data, const int &slot);

    void signal_cplx_spcdata(const std::vector<std::complex<double>> &data, const int &slot);

    void signal_atm_exclude_tscat(const size_t &start, const size_t &stop);


    /*!
     * \brief signal_ts_reader_mode emits the actual status - which may be logically different from the setter
     * \param tsplotter_buffer_type_ts
     * \param tsplotter_buffer_type_spc
     * \param tsplotter_detrend_active
     */
    void signal_ts_reader_mode(const atsfileout &tsplotter_buffer_type_ts, const atsfileout &tsplotter_buffer_type_spc, const bool &tsplotter_detrend_active);



public slots:



    void close(const bool rewrite = false);


    /*!
       \brief slide_to_second - slides to a certain UTC time; uint seconds since 1970
       emits this->QDataStreamStatus or slided;
       \param timestamp - will be corrected in case inside BUT when we have 0.25Hz we may take the next smaller time
       \return samples slided
     */
    QDataStream::Status slot_slide_to_time(const eQDateTime &edt_time, eQDateTime *corrected_time = nullptr);

    /*!
     * \brief sync_for_max_min_time call this BEFORE set window length; mc_data will do this for you; others not; ats will slide and move to pos
     * \param edt_time_starts_other latest start of all files
     * \param edt_time_stops_other  earliest stop of all files
     * \return
     */
    QDataStream::Status sync_for_max_min_time(const eQDateTime &edt_time_starts_other, const eQDateTime &edt_time_stops_other);


    /*!
       \brief slide_to_sample sample number to be read next; say 1024 and the inbuffer stays at 1023 so that the next read operation takes 1024th sample
       emits this->QDataStreamStatus or slided (from inside)
       \param sample_no - use eQDatetime to calculate the sample in case;
       \return QDataStream::Status
     */
    QDataStream::Status slot_slide_to_sample(const quint64 &sample_no);

//    /*!
//     * \brief slot_atswriter_data_qmap_created fetch the data (from XML e.g.) and fill in my values - for example after filtering; in this case connect only ht out files with
//     * this signal - that is almost ever the case!
//     * \param data_map
//     */
//    void slot_atswriter_data_qmap_created(const QMap<QString, QVariant> &data_map);




    QDataStream::Status get_double_samples(std::vector<double> &v, const bool scaleme = true);

    QDataStream::Status set_double_samples(const std::vector<double> &v);
    QDataStream::Status mytsdata_tofile();


    /*!
       \brief slide_to_old_pos slides back to the last read
       emits this->atsfile_closed or slided
       \return QDataStream::Status
     */
    QDataStream::Status slot_slide_to_old_pos();


    QDataStream::Status write();



    QDataStream::Status read();



    /*!
     * \brief slot_ts_reader_mode - prepares the timeseries to be emitted
     *
     * atsfileout::atsfileout_void, atsfileout::atsfileout_void - function returns nothing <br>
     * atsfileout::atsfileout_unscaled_timeseries, atsfileout::atsfileout_void - function emits RAW timeseries <br>
     * atsfileout::atsfileout_scaled_timeseries, atsfileout::atsfileout_void - function emits SCALED timeseries (e.g. mV/km, mV ) <br>
     * atsfileout::atsfileout_scaled_timeseries, atsfileout::atsfileout_void, true - function emits SCALED and DETRENDED timeseries (e.g. mV/km, mV) <br>
     * as long tsplotter_buffer_type_spc is atsfileout::atsfileout_void you save a lot of computation time - in case spectra are active you can't save any CPU time <br><br>
     * once SPECTRA are ACTIVE timeseries will be scaled! and detrended! automatically - because (except from hanning IS THE INPUT for the FFT) <br>
     * atsfileout::atsfileout_scaled_timeseries, atsfileout::atsfileout_spectra, true - function emits SCALED timeseries (e.g. mV/km, mV ) and spectra <br>
     * atsfileout::atsfileout_scaled_timeseries, atsfileout::atsfileout_calibrated_spectra, true - function emits SCALED timeseries (e.g. mV/km, mV ) and CALIBRATED spectra <br>
     *
     * now the inverse with calibrated spectra become active with atsfileout_calibrated_scaled_timeseries
     *
     * atsfileout::atsfileout_calibrated_scaled_timeseries, atsfileout::atsfileout_calibrated_spectra, true - function emits SCALED CALIBRATED timeseries (e.g. mV/km, mV ) and CALIBRATED spectra <br>
     *
     *
     * \param tsplotter_buffer_type_ts : atsfileout_unscaled_timeseries, atsfileout_scaled_timeseries, atsfileout_calibrated_scaled_timeseries (AFTER FFT!) <br>
     * \param tsplotter_buffer_type_spc : atsfileout_void (OFF!), atsfileout_spectra, atsfileout_calibrated_spectra <br>
     * \param tsplotter_detrend_active - do we want to detrend the display
     * \return emits a signal \see signal_ts_reader_mode
     */
    void slot_ts_reader_mode(std::shared_ptr<std::vector<double> > plotter_frequencies,
            const atsfileout &tsplotter_buffer_type_ts = atsfileout::atsfileout_void, const atsfileout &tsplotter_buffer_type_spc = atsfileout::atsfileout_void,
                             const bool &tsplotter_detrend_active = false);

    /*!
     * \brief read_tsplotter emits a vector of timeseries and / or spectral amplitudes;
     *  use slot_ts_reader_mode to trigger the wanted actions
     *
     */
    void read_tsplotter(const bool emits = true, const bool stack_all = false);

    void read_all_tsplotter();
    void emit_stacked();




    //    /*!
    //       \brief read_all_join reads the complete data and waits for ALL streams
    //     */
    //    void read_all_join();

    //    /*!
    //       \brief read_all_individual  reads the complete data and does NOT wait for others streams
    //       e.g. this is a producer consumer thread where this read is connected to an individual output stream<br>
    //       inside the lock the ats_thrd_tsdata_ready is emitted. So if we have the lock, the data has been written already
    //       and the copy process does not violate the write to disk funktion (or other function)
    //     */

    void read_all();

    /*!
     * \brief single_read_all
     * \param all_data contains either mV/km for E or mV for H
     * \return
     */

    /*!
     * \brief read_all_single read all at once; result will / shall be moved autside
     * \param inverse_fft calculate inverse and OVERWRITE tsdata input
     * \param theo_only for hugh files with sample freq <= 512 is ok; forces regardless so also for higher frequencies which is not a good idea; implement logic somwhere else
     * \param write_immedeately move out by signal
     */
    void read_all_single(const bool inverse_fft, const bool write_immedeately);

    /*!
       \brief set_remote set this file as remote reference
     */
    void set_remote(const bool is_remote);

    /*!
       \brief get_remote ask remote reference status
       \return
     */
    bool get_remote() const;

    /*!
     * \brief set_firfilter set a FIR filter from the filter class; coeffiencients will generated inside the class
     *
     * \param xfirfil
     * \return
     */
    bool set_firfilter(std::shared_ptr<firfilter> xfirfil, const bool shift_to_full_second = true);


    /*!
     * \brief skip_samples_from_filter add skip_samples in that way that the filtered time series starts at a full second again
     * example: 128Hz, 32x filter, 471 coefficients = 235 half length, we start at sample 20 (20 + 235 = 255 = 2nd second)<br>
     * the filter is part of the class and can be accessed by this function
     */

    QDataStream::Status skip_samples_from_filter();

    /*!
     * \brief set_progress_bar_resolution emits the actual read samples; the progress bar has to be set to 500 then 10 percent emits after 50, 100 .. 450, 500 samples; do this BEFORE you set window length!
     * \param one_to_twenty_percent
     * \return
     */
    bool set_progress_bar_resolution(const unsigned int &one_to_twenty_percent = 0);


    int get_slot() const;

    void set_slot(const int &slot);

    void set_ats_options(const prc_com &cmdline);

    size_t queue_data_to_vector();

    size_t get_override_use_samples() const;



    //    void set_emit_ats_thrd_tsdata_ready(const bool active = true);

    //    void set_emit_ats_thrd_spcdata_ready(const bool active = true);

    //    void set_emit_ats_thrd_inverse_spcdata_ready(const bool active = true);

    //    void set_emit_ats_thrd_spcdata_ampl_ready(const bool active = true);



private:


    int buffer_type = 0;                                         //!< which output: timeseries, spectra ...see procmt_alldefines.h
    int tsplotter_buffer_type_ts = 0;                            //!< wich buffer to emit for tsplotter, time series
    int tsplotter_buffer_type_spc = 0;                           //!< wich buffer to emit for tsplotter, spectra
    bool tsplotter_detrend_active = false;
    qint64 old_filepos = 0;
    bool scale_me = true;                                        //!< mostly want mV/km

    size_t move_ahead_after_read = 0;                            //!< move for example 32 point ahead when doing decimation filter
    size_t move_back_after_read = 0;                             //!< move back for example when doing overlapping for FFT
    //size_t skip_first_samples_read = 0;                          //!< skip samples after opening the file; normally NOT needed because we slide ONLINE/open to the position



    size_t ats_read_counts = 0;                                  //!< local read counts  / loops / windows
    size_t ats_write_counts = 0;                                 //!< local write counts / loops / windows

    quint64 override_use_samples = 0;                            //!< when use sync_for_max_min_time we have the use samples re-defined


    size_t max_counts = 0;                                       //!< emergency break; set to 1 in open to start the loop only
    size_t samples_written = 0;                                  //!< count samples written
    size_t samples_read = 0;                                     //!< count samples read


    std::vector<double> tsdata;                                  //!< time series data
    std::vector<double> tsdata_stacked;                          //!< time series data stacked
    std::shared_ptr<threadbuffer<double>> tsbuffer;              //!< output bufferof tsdata / stacked ts data

    std::vector<double> tsdata_overlap;                          //!< time series data
    std::vector<double> tsdata_firfiltered;                      //!< low / high pass, decimation - we don't want scale here

    std::vector<std::complex<double>> spcdata;                   //!< spectra data
    std::vector<std::complex<double>> spcdata_calibrated;        //!< spectra data calibrated
    std::shared_ptr<threadbuffer<std::complex<double>>> spcbuffer;    //!< output for complex spectra as needed for MT

    std::vector<double> spc_ampl_data;                           //!< spectra data - amplitude
    std::vector<double> spc_ampl_data_stacked;
    std::vector<double> spc_ampl_calib_data;                     //!< spectra data - amplitude, calibrated as needed for most sensors
    std::vector<double> spc_ampl_calib_data_stacked;             //!< spectra data - amplitude, calibrated as needed for most sensors
    // stacked phase makes no sense
    std::shared_ptr<threadbuffer<double>> spc_amplbuffer;        //!< output for double spectra - such as amplitude


    std::vector<int> ts_intdata;                                 //!< time series data as raw int; you need a LSB first
    std::shared_ptr<threadbuffer<int>> ts_intbuffer;             //!< output bufferof tsdata as integers; you need the LSB to do that!
    std::shared_ptr<threadbuffer<QString>> ts_strbuffer;         //!< output bufferof tsdata as strings cvs
    int csv_buffer_status = 0;
    std::vector<QString> csv_buffer_strs;

    int tsbuffer_status = 0;
    double fcut_upper = 0;                                       //!<  for MT the complete spectra may not be needed; use 0.05 to cut some upper
    double fcut_lower = 0;                                       //!<  for MT the complete spectra may not be needed; use 0.1 to cut 10% lower




    bool isdcfft = false;                                        //!<  DC part of FFT is off
    bool bwincal = true;                                         //!<  calibrate the FFT by window length (make it independend from window)
    bool nspc = false;                                           //!< do not generate complex spectra if only inverse timeseriea are needed
    bool inverse_from_forward = false;                           //!< calculate a full inverse fft - e.g. for calibrated timeseries


    std::vector<double> fir_fil_coeff;                           //!< filter coefficients
    double fir_fil_output = 0;                                   //!< FIR filter output
    std::unique_ptr<firfilter> firfil;                           //!< make a FIR filter

    std::unique_ptr<fftreal_vector> fftreal = nullptr;           //!< make a fft
    std::unique_ptr<fftreal_vector> fftfull = nullptr;           //!< needed for full inversion for tsplotter displaying inverted timeseries
    std::shared_ptr<std::vector<double> > plotter_frequencies = nullptr;   //!< plotter takes mostly full fft, so fetch the frequencies the plotter wants


    //std::vector<double> freqs;                                   //!< frequencies from fft low to high

    std::vector<size_t> progress_bar_emits_at;                   //!< when ats_read_counts (aka loops) are in vector we can emit; modulo "%" does not work with large numbers

    size_t last_read_size = 0;                                   //!< last remaining window
    std::queue<std::vector<double>> queue_data;                  //!< for reading CSV JSON data


    //    bool emit_ats_thrd_tsdata_ready = true;                      //!< emits ready if ts data is there for further processing
    //    bool emit_ats_thrd_spcdata_ready = true;                     //!< emits ready if fft data is ready for further processing
    //    bool emit_ats_thrd_spcdata_ampl_ready = true;                //!< emits ready if fft data is ready for further processing
    //    bool emit_ats_thrd_spcdata_ampl_calib_ready = true;          //!< emits ready if fft data is ready for further processing
    //    bool emit_ats_thrd_spcdata_cplx_calib_ready = true;          //!< emits ready if fft data is ready for further processing
    //    bool emit_ats_thrd_inverse_spcdata_ready = true;             //!< emits ready if inverse fft data is ready for further processing

};



#endif // ATSFILE_H
